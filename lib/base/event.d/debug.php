<?
/**
 * Basic debug library
 * 
 * @version    $Id$
 * @author     Rasmus Andersson  http://hunch.se/
 * @package    ab
 * @subpackage base
 */

/** @ignore Message generator */
if(!defined('DEBUG_FORMAT_HANDLER')) define('DEBUG_FORMAT_HANDLER', 'debug_fmt_html');

/** @ignore Output handler */
#if(!defined('DEBUG_OUTPUT_HANDLER')) define('DEBUG_OUTPUT_HANDLER', 'echo');

/**
 * Used for internal debugging
 * 
 * <b>Related constants:</b>
 *
 * <b><samp>DEBUG</samp></b> A glob pattern, whos matched transmitters messages is printed. 
 * If this constant is not defined, this library should NOT be loaded, but be substituted
 * with an empty debug() function. ie. <samp>function debug($a=0,$b=0){}</samp>.
 *   - Show everything: <samp>define('DEBUG', '.*')</samp>
 *   - Show static class calls: <samp>define('DEBUG', '.+::.+')</samp>
 *   - Show function calls: <samp>define('DEBUG', '::.+')</samp>
 *   - Show calls in the line range 20-80: <samp>define('DEBUG', '.+[2-8][0-9]')</samp>
 *   - Show all calls in MyClass: <samp>define('DEBUG', 'MyClass.+')</samp>
 *
 *
 * 
 * <b><samp>DEBUG_FORMAT_HANDLER</samp></b> Function which format and generates a string message, later
 * passed on to the <samp>DEBUG_OUTPUT_HANDLER</samp> function.
 *
 * <i>Example:</i>
 *   - Use built in HTML formatter: <samp>define('DEBUG_FORMAT_HANDLER', 'debug_fmt_html')</samp>
 *
 * Built in formatters: <samp>debug_fmt_txt, debug_fmt_html, debug_fmt_xml</samp><br />
 * Syntax: <samp>string my_handler( string $class, bool $static, string $method, string $file, int $line, string $message )</samp>
 *
 *
 *
 * <b><samp>DEBUG_OUTPUT_HANDLER</samp></b> A function responsible for displaying or storing
 * a debug message, generated by the <samp>DEBUG_FORMAT_HANDLER</samp> function.
 * Defaults to <samp>echo</samp>.<br />
 * Syntax: <samp>void my_handler( string $message )</samp>
 *
 * 
 * @param  string  Message
 * @param  int     Trace offset (best left at 1)
 * @return void
 */
function debug($msg='', $traceOffset = 1)
{		
	$t = debug_backtrace();
	
	while(!isset($t[$traceOffset]) && $traceOffset > 0)
		$traceOffset--;
	
	if(isset($t[$traceOffset]['type'])) {
		if(!preg_match('/^'.DEBUG.'$/i', $t[$traceOffset]['class'].$t[$traceOffset]['type'].$t[$traceOffset]['function']))
			return;
		$to = ($traceOffset<1) ? 0 : $traceOffset-1;
		$msg = call_user_func(DEBUG_FORMAT_HANDLER, 
			$t[$traceOffset]['class'], 
			($t[$traceOffset]['type'] == '::'), 
			$t[$traceOffset]['function'],
			$t[$to]['file'], 
			$t[$to]['line'], $msg);
	}
	else {
		if(!preg_match('/^'.DEBUG.'$/i', $t[$traceOffset]['function']))
			return;
		$to = ($traceOffset<1) ? 0 : $traceOffset-1;
		$msg = call_user_func(DEBUG_FORMAT_HANDLER, 
			'', true, 
			$t[$traceOffset]['function'],
			$t[$to]['file'], 
			$t[$to]['line'], $msg);
	}
	
	if(defined('DEBUG_OUTPUT_HANDLER'))
		call_user_func(DEBUG_OUTPUT_HANDLER, $msg);
	else
		echo $msg;
}

/** @ignore Text formatter */
function debug_fmt_txt($class, $static, $method, $file, $line, $message) {
	return "[$class" . ($static ? '::' : '->') . "$method():$line] $message\n";
}

/** @ignore HTML formatter */
function debug_fmt_html($class, $static, $method, $file, $line, $message) {
	return '<tt class="debugmsg" title="'.Utils::relativePath($file, realpath(dirname(__FILE__).'/../..')).':'.$line.'">' . $class . ($static ? '::' : '->') 
		. $method . '():' . $line . '&#8250;' .($message ? ' <span>' . $message . '</span>' : ''). "</tt><br />\n";
}

/** @ignore XML formatter */
function debug_fmt_xml($class, $static, $method, $file, $line, $message) {
	return '<msg class="' . $class 
		. '" method="' . $method
		. '" static="'.($static ? 'yes' : 'no')
		. '" file="' . $file
		. '" line="' . $line . '"' . ($message ?
		(strtr($message,array('&'=>'&#38;','<'=>'&#60;','>'=>'&#62;')) . '</msg') : ' /') . ">\n";
}

?>